

# This file was *autogenerated* from the file SSSA.sage
from sage.all_cmdline import *   # import sage library

_sage_const_16857450949524777441941817393974784044780411511252189319 = Integer(16857450949524777441941817393974784044780411511252189319); _sage_const_16857450949524777441941817393974784044780411507861094535 = Integer(16857450949524777441941817393974784044780411507861094535); _sage_const_77986137112576 = Integer(77986137112576); _sage_const_5732560139258194764535999929325388041568732716579308775 = Integer(5732560139258194764535999929325388041568732716579308775); _sage_const_14532336890195013837874850588152996214121327870156054248 = Integer(14532336890195013837874850588152996214121327870156054248); _sage_const_2609506039090139098835068603396546214836589143940493046 = Integer(2609506039090139098835068603396546214836589143940493046); _sage_const_8637771092812212464887027788957801177574860926032421582 = Integer(8637771092812212464887027788957801177574860926032421582); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1)
p = _sage_const_16857450949524777441941817393974784044780411511252189319 
A = _sage_const_16857450949524777441941817393974784044780411507861094535 
B = _sage_const_77986137112576 

# y^2 = x^3 + A * x + B
tE = EllipticCurve(GF(p), [A, B])

tP = tE(_sage_const_5732560139258194764535999929325388041568732716579308775 ,
        _sage_const_14532336890195013837874850588152996214121327870156054248 )
tQ = tE(_sage_const_2609506039090139098835068603396546214836589143940493046 ,
        _sage_const_8637771092812212464887027788957801177574860926032421582 )


# it is useful if E's order is p.
def lift_up(point, a4, a6, p):
    # y^2=x^3+a4*x+a6 in Z/pZ
    E = EllipticCurve(Zmod(p ** _sage_const_2 ), [a4, a6])
    # \alpha(s,t)
    s, t = point.xy()
    # Z/p^2Z
    p2Z = Zmod(p ** _sage_const_2 )
    # randomly choose a X1 mod p = s and it can be s it self
    X1 = p2Z(s)
    ###########generate Y1##########
    y = p2Z(t)
    omega = (((ZZ(X1) ** _sage_const_3 +a4*ZZ(X1)+a6-ZZ(y) ** _sage_const_2 )/p) % p)/(_sage_const_2 *t)
    # if aseert work then pls change X1.
    assert omega != _sage_const_0 
    Y1 = y+p*p2Z(omega)
    ################################
    # X1, Y1 is a ZZ point in E(Z/p^2Z)
    A = E(X1, Y1)
    Xp_1, Yp_1 = ((p-_sage_const_1 )*A).xy()
    # check if lambda_E is not zero
    assert X1 != Xp_1
    lambda_E = ((ZZ(Xp_1)-ZZ(X1))/p % p)/((ZZ(Yp_1)-ZZ(Y1)) % p)
    pZ = Zmod(p)
    # lambda_E is in Z/pZ
    lambda_E = pZ(lambda_E)
    return lambda_E


if __name__ == "__main__":
    lambda_P = lift_up(tP, A, B, p)
    lambda_Q = lift_up(tQ, A, B, p)
    c = lambda_Q/lambda_P
    if tQ == ZZ(c)*tP:
        print("ok!")
    print(f"secret_key: {c}")

